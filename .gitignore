local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local gameSettings = ReplicatedStorage:WaitForChild("GameSettings")
local remotes = gameSettings:WaitForChild("Remotes")
local modules = ServerStorage:WaitForChild("Modules")

-- Helper functions
local function getCharacterComponents(player)
    local char = player.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    local ball = char:FindFirstChild("Ball")
    local values = char:FindFirstChild("Values")
    if not values then return char, humanoid, root end
    local shooting = values:FindFirstChild("Shooting")
    local contest = values:FindFirstChild("Contest")
    local scriptsFolder = char:FindFirstChild("Scripts")
    local animations = scriptsFolder and scriptsFolder:FindFirstChild("Animations") and scriptsFolder.Animations:GetChildren() or {}
    return char, humanoid, root, ball, values, shooting, contest, animations
end

local function getGoalModule()
    return require(modules:FindFirstChild("_Goal"))
end

local function calculateOffset(barsize, percent)
    local max, min = 0, 1.25
    if barsize > 0.5 then
        return (percent * (max - min) / 100) + min
    else
        return (percent * (max + min) / 100) - min
    end
end

local function calculatePercent(barsize, contestValue)
    local adjusted = barsize
    if barsize > 0.5 then
        adjusted = 0.5 - (0.5 - barsize) * -1
    end
    local base = (adjusted / 0.5) * 100
    local percent = math.clamp(base + 5 - (contestValue or 0), 0, 100)
    return math.floor(percent)
end

local function setupBodyGyro(root, target)
    local bg = Instance.new("BodyGyro")
    bg.Parent = root
    bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bg.D = 275
    bg.P = 5000
    bg.CFrame = CFrame.lookAt(root.Position, Vector3.new(target.Position.X, root.Position.Y, target.Position.Z))
    return bg
end

local function onRelease(ball, goal, barsize, percent)
    local magnitude = (ball.Position - goal.Position).Magnitude
    local t = 1.1 + magnitude / 110
    local g = Vector3.new(0, -workspace.Gravity / math.pi, 0)
    local x0 = ball.Position
    local v0 = (goal.Position - x0 - 0.5 * g * t * t) / t / 1.035
    local offset = calculateOffset(barsize, percent)
    ball.Connect.Part0 = nil
    ball.Parent = workspace
    ball.Velocity = v0 + Vector3.new(offset, offset, offset)
    ball:SetNetworkOwner(nil)
    ball.RotVelocity = Vector3.new(0, 0, 15)
    wait(1.25)
    if ball:FindFirstChild("Settings") and ball.Settings:FindFirstChild("Welder") then
        ball.Settings.Welder.Value = ""
    end
end

local function setupShotMeter(root)
    local shotMeter = root:FindFirstChild("ShotmeterUI")
    local meter = shotMeter and shotMeter:FindFirstChild("Meter")
    local bar = meter and meter:FindFirstChild("Bar")
    return shotMeter, meter, bar
end

local function createTweens(bar, animationLength)
    local barTweenInfo = TweenInfo.new(animationLength / 2, Enum.EasingStyle.Linear)
    local stopTweenInfo = TweenInfo.new(0, Enum.EasingStyle.Linear)
    local barTween = TweenService:Create(bar, barTweenInfo, {Size = UDim2.new(1, 0, -1, 0)})
    local stopTween = TweenService:Create(bar, stopTweenInfo, {Size = UDim2.new(1, 0, bar.Size.Y.Scale, 0)})
    return barTween, stopTween
end

local function stopDribbleAnimations(animations)
    for _, anim in pairs(animations) do
        if anim.Name:match("Dribble") then
            anim:Stop()
        end
    end
end

local function waitForAlignment(root, goal)
    repeat
        wait()
    until (root.Position - goal.Position).Magnitude < 0.1
end

local function handleShotRelease(animations, bar, ball, goal, shooting, contest)
    local jumpShot = animations["Jumpshot-1"]
    if jumpShot then
        jumpShot.KeyframeReached:Connect(function(frame)
            if frame == "Release" then
                local percent = calculatePercent(-bar.Size.Y.Scale, contest and contest.Value or 0)
                onRelease(ball, goal, -bar.Size.Y.Scale, percent)
                if shooting then shooting.Value = false end
                if contest then contest.Value = 0 end
            end
        end)
    end
end

local function resetShotMeter(bar)
    if bar then
        bar.Size = UDim2.new(1, 0, 0, 0)
    end
end

local function setWalkSpeed(humanoid, speed)
    if humanoid then
        humanoid.WalkSpeed = speed
    end
end

local function cleanupBodyGyro(bg)
    if bg then bg:Destroy() end
end

-- Extended utility functions
local function findBallHandler()
    for _, v in pairs(workspace:GetDescendants()) do
        if v.Name == "Ball" and v.Parent:FindFirstChild("Humanoid") then
            return v.Parent, v.Parent:FindFirstChild("HumanoidRootPart")
        end
    end
end

local function calculateDistance(a, b)
    if a and b then
        return (a.Position - b.Position).Magnitude
    end
    return math.huge
end

local function processStandingShot(player, char, humanoid, root, ball, values, shooting, contest, animations)
    local goalModule = getGoalModule()
    local goal = goalModule:Goal("Goal", root)
    local shotMeter, meter, bar = setupShotMeter(root)
    if not (shotMeter and meter and bar) then return end
    local animationLength = (animations["Jumpshot-1"] and animations["Jumpshot-1"].Length) or 1
    local barTween, stopTween = createTweens(bar, animationLength)
    if shooting then shooting.Value = true end
    stopDribbleAnimations(animations)
    local bg = setupBodyGyro(root, goal)
    setWalkSpeed(humanoid, 0)
    waitForAlignment(root, goal)
    if animations["Jumpshot-1"] then
        animations["Jumpshot-1"]:Play(0.5)
        handleShotRelease(animations, bar, ball, goal, shooting, contest)
    end
    barTween:Play()
    wait(animationLength + 0.25)
    cleanupBodyGyro(bg)
    setWalkSpeed(humanoid, 16)
    resetShotMeter(bar)
end

local function guardPlayer(player, char, humanoid, root, values)
    local guarding = values:FindFirstChild("Guarding")
    if not guarding then return end
    local handler, handlerRoot = findBallHandler()
    if not (handler and handlerRoot) then return end
    local dist = calculateDistance(root, handlerRoot)
    if dist < 10 then
        humanoid.WalkSpeed = 24
    else
        humanoid.WalkSpeed = 16
    end
end

-- Remote connections
remotes.Shoot.OnServerEvent:Connect(function(player, _, action)
    local char, humanoid, root, ball, values, shooting, contest, animations = getCharacterComponents(player)
    if not (char and humanoid and root and ball and values and shooting and contest and animations) then return end
    if action == 1 then
        processStandingShot(player, char, humanoid, root, ball, values, shooting, contest, animations)
    elseif action == 2 then
        local _, stopTween = createTweens((setupShotMeter(root))[3], animations["Jumpshot-1"] and animations["Jumpshot-1"].Length or 1)
        stopTween:Play()
    end
end)

remotes.Guard.OnServerEvent:Connect(function(player, _, _)
    local char, humanoid, root, _, values, _, _, animations = getCharacterComponents(player)
    if not (char and humanoid and root and values and animations) then return end
    guardPlayer(player, char, humanoid, root, values)
end)

-- Ball pickup/drop logic
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        local root = char:WaitForChild("HumanoidRootPart")
        local ball = char:FindFirstChild("Ball")
        local values = char:FindFirstChild("Values")
        if not (ball and values) then return end
        ball.Touched:Connect(function(hit)
            local hitChar = hit.Parent
            if hitChar and hitChar:FindFirstChild("Humanoid") then
                local playerHolding = Players:GetPlayerFromCharacter(hitChar)
                if playerHolding and values:FindFirstChild("HasBall") then
                    values.HasBall.Value = true
                    ball.Anchored = false
                    ball.CFrame = root.CFrame * CFrame.new(0, 2, 0)
                end
            end
        end)
    end)
end)

-- Cleanup: ensure balls don't stick
for _, ball in pairs(Workspace:GetDescendants()) do
    if ball.Name == "Ball" and ball:IsA("BasePart") then
        ball.Anchored = false
    end
end
